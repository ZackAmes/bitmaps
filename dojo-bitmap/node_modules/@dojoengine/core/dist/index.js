// src/provider/DojoProvider.ts
import {
  RpcProvider,
  Contract,
  shortString
} from "starknet";

// src/provider/provider.ts
var Provider = class {
  // Store the address of the world.
  worldAddress;
  /**
   * Constructor: Initializes the Provider with a given world address.
   *
   * @param {string} worldAddress - The address of the world.
   */
  constructor(worldAddress) {
    this.worldAddress = worldAddress;
  }
  /**
   * Retrieves the stored world address.
   *
   * @returns {string} - The address of the world.
   */
  getWorldAddress() {
    return this.worldAddress;
  }
};

// src/types/index.ts
var WorldEntryPoints = /* @__PURE__ */ ((WorldEntryPoints2) => {
  WorldEntryPoints2["get"] = "entity";
  WorldEntryPoints2["set"] = "set_entity";
  WorldEntryPoints2["entities"] = "entities";
  WorldEntryPoints2["execute"] = "execute";
  WorldEntryPoints2["registerSystem"] = "register_system";
  WorldEntryPoints2["registerComponent"] = "register_model";
  WorldEntryPoints2["model"] = "model";
  WorldEntryPoints2["system"] = "system";
  WorldEntryPoints2["metadataUri"] = "metadata_uri";
  WorldEntryPoints2["setMetadataUri"] = "set_metadata_uri";
  WorldEntryPoints2["registerModel"] = "register_model";
  WorldEntryPoints2["deployContract"] = "deploy_contract";
  WorldEntryPoints2["upgradeContract"] = "upgrade_contract";
  WorldEntryPoints2["uuid"] = "uuid";
  WorldEntryPoints2["emit"] = "emit";
  WorldEntryPoints2["entityIds"] = "entity_ids";
  WorldEntryPoints2["setExecutor"] = "set_executor";
  WorldEntryPoints2["executor"] = "executor";
  WorldEntryPoints2["base"] = "base";
  WorldEntryPoints2["deleteEntity"] = "delete_entity";
  WorldEntryPoints2["isOwner"] = "is_owner";
  WorldEntryPoints2["grantOwner"] = "grant_owner";
  WorldEntryPoints2["revokeOwner"] = "revoke_owner";
  WorldEntryPoints2["isWriter"] = "is_writer";
  WorldEntryPoints2["grantWriter"] = "grant_writer";
  WorldEntryPoints2["revokeWriter"] = "revoke_writer";
  return WorldEntryPoints2;
})(WorldEntryPoints || {});

// src/constants/index.ts
var LOCAL_KATANA = "http://127.0.0.1:5050";

// src/utils/index.ts
var getContractByName = (manifest, name) => {
  return manifest.contracts.find((contract) => {
    const nameParts = contract.name.split("::");
    return nameParts[nameParts.length - 1] === name || contract.name === name;
  })?.address || "";
};
var parseModelName = (model) => {
  const acronyms = /* @__PURE__ */ new Set(["ERC"]);
  return model.name.split("::").pop().split("_").map((part) => {
    if (acronyms.has(part.toUpperCase())) {
      return part.toUpperCase();
    }
    if (!isNaN(parseInt(part))) {
      return part;
    }
    return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
  }).join("");
};

// src/provider/DojoProvider.ts
var DojoProvider = class extends Provider {
  provider;
  contract;
  manifest;
  /**
   * Constructor: Initializes the DojoProvider with the given world address, manifest and URL.
   *
   * @param {string} world_address - Address of the world.
   * @param {string} [url=LOCAL_KATANA] - RPC URL (defaults to LOCAL_KATANA).
   */
  constructor(manifest, url = LOCAL_KATANA) {
    super(manifest.world.address);
    this.provider = new RpcProvider({
      nodeUrl: url
    });
    this.contract = new Contract(
      manifest.world.abi,
      this.getWorldAddress(),
      this.provider
    );
    this.manifest = manifest;
  }
  /**
   * Retrieves a single entity's details.
   *
   * @param {string} model - The component to query.
   * @param {Array<string>} keys - The keys to query.
   * @param {number} [offset=0] - Starting offset (defaults to 0).
   * @param {number} [length=0] - Length to retrieve (defaults to 0).
   * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entity's details.
   */
  async entity(model, keys, offset = 0, length = 0, layout) {
    try {
      return await this.contract.call("entity" /* get */, [
        shortString.encodeShortString(model),
        keys.length,
        ...keys,
        offset,
        length,
        layout.length,
        layout
      ]);
    } catch (error) {
      throw error;
    }
  }
  /**
   * Retrieves multiple entities' details.
   *
   * @param {string} model - The component to query.
   * @param {number} index - The index to query.
   * @param {Array<string>} values - The values to query.
   * @param {number} valuesLength - The values length to query.
   * @param {Array<number>} valuesLayout - The values layout to query.
   */
  async entities(model, index, values, valuesLength, valuesLayout) {
    try {
      return await this.contract.call("entities" /* entities */, [
        shortString.encodeShortString(model),
        index,
        values,
        valuesLength,
        valuesLayout
      ]);
    } catch (error) {
      throw error;
    }
  }
  /**
   * Retrieves a models
   *
   * @param {string} name - Name of the model.
   * @returns {Promise<bigint>} - A promise that resolves to a bigint representing the model's details.
   */
  async model(name) {
    try {
      return await this.contract.call("model" /* model */, [
        shortString.encodeShortString(name)
      ]);
    } catch (error) {
      throw error;
    }
  }
  /**
   * Executes a function with the given parameters.
   * This function is a wrapper around the Starknet.js Account.execute function, but is more convenient to use.
   *
   * ```ts
   * await provider.execute(signer, contract, system, call_data);
   * ```
   * @param {Account} account - The account to use.
   * @param {string} contract - The contract to execute.
   * @param {string} call - The function to call.
   * @param {num.BigNumberish[]} call_data - The call data for the function.
   * @param {InvocationsDetails | undefined} transactionDetails - The transactionDetails allow to override maxFee & version
   * @returns {Promise<InvokeFunctionResponse>} - A promise that resolves to the response of the function execution.
   */
  async execute(account, contract_name, call, calldata, transactionDetails) {
    try {
      const nonce = await account?.getNonce();
      return await account?.execute(
        {
          contractAddress: getContractByName(
            this.manifest,
            contract_name
          ),
          entrypoint: call,
          calldata
        },
        void 0,
        {
          maxFee: 0,
          // TODO: Update this value as needed.
          ...transactionDetails,
          nonce
        }
      );
    } catch (error) {
      throw error;
    }
  }
  /**
   * Executes a multicall.
   * This function is a wrapper around the Starknet.js Account.execute function, but allows for executing multiple calls at once.
   *
   * ```ts
   * await provider.executeMulti(account, calls);
   * ```
   * @param {Account} account - The account to use.
   * @param {AllowArray<Call>} calls - The calls to execute.
   * @param {InvocationsDetails | undefined} transactionDetails - The transactionDetails allow to override maxFee & version
   * @returns {Promise<InvokeFunctionResponse>} - A promise that resolves to the response of the function execution.
   */
  async executeMulti(account, calls, transactionDetails) {
    try {
      const nonce = await account?.getNonce();
      return await account?.execute(calls, void 0, {
        maxFee: 0,
        // TODO: Update this value as needed.
        ...transactionDetails,
        nonce
      });
    } catch (error) {
      throw error;
    }
  }
  /**
   * Retrieves current uuid from the world contract.
   *
   * @returns {Promise<number>} - A promise that resolves to the world uuid
   * @throws {Error} - Throws an error if the call fails.
   *
   * @example
   * const uuid = await provider.uuid();
   * console.log(uuid);
   * // => 6
   *
   */
  async uuid() {
    try {
      const { result } = await this.provider.callContract({
        contractAddress: this.getWorldAddress(),
        entrypoint: "uuid" /* uuid */,
        calldata: []
      });
      if (result && result.length === 1) {
        return parseInt(result[0]);
      }
      throw new Error("Contract did not return expected uuid");
    } catch (error) {
      throw new Error(`Failed to fetch uuid: ${error}`);
    }
  }
  /**
   * Calls a function with the given parameters.
   *
   * @param {string} contract - The contract to call.
   * @param {string} call - The function to call.
   * @returns {Promise<CallContractResponse>} - A promise that resolves to the response of the function call.
   */
  async call(contract_name, call, calldata) {
    try {
      return await this.provider.callContract({
        contractAddress: getContractByName(
          this.manifest,
          contract_name
        ),
        entrypoint: call,
        calldata
      });
    } catch (error) {
      throw new Error(`Failed to call: ${error}`);
    }
  }
};
export {
  DojoProvider,
  WorldEntryPoints,
  getContractByName,
  parseModelName
};
//# sourceMappingURL=index.js.map