import { RpcProvider, Contract, Account, num, InvocationsDetails, InvokeFunctionResponse, AllowArray, Call, CallContractResponse } from 'starknet';

/**
 * Enumeration representing various entry points or functions available in the World.
 */
declare enum WorldEntryPoints {
    get = "entity",// Retrieve a single entity
    set = "set_entity",// Set or update a single entity
    entities = "entities",// Retrieve multiple entities
    execute = "execute",// Execute a specific command
    registerSystem = "register_system",// Register a new system
    registerComponent = "register_model",// Register a new component
    model = "model",// Access a component
    system = "system",// Access a system
    metadataUri = "metadata_uri",// Retrieve metadata URI for a resource
    setMetadataUri = "set_metadata_uri",// Set metadata URI for a resource
    registerModel = "register_model",// Register a new model
    deployContract = "deploy_contract",// Deploy a contract and return its address
    upgradeContract = "upgrade_contract",// Upgrade a contract
    uuid = "uuid",// Retrieve the UUID of the world
    emit = "emit",// Emit an event
    entityIds = "entity_ids",// Retrieve entity IDs for a model
    setExecutor = "set_executor",// Set executor for the world
    executor = "executor",// Retrieve the executor's address
    base = "base",// Retrieve base class hash
    deleteEntity = "delete_entity",// Delete an entity
    isOwner = "is_owner",// Check if an address is an owner of a resource
    grantOwner = "grant_owner",// Grant ownership of a resource
    revokeOwner = "revoke_owner",// Revoke ownership of a resource
    isWriter = "is_writer",// Check if a system is a writer for a model
    grantWriter = "grant_writer",// Grant writer permission
    revokeWriter = "revoke_writer"
}
/**
 * World interface: An interface that defines the methods that a world must implement.
 * Dojo v0.4.0
 */
interface IWorld {
    metadataUri?(resource: string): Promise<Array<string>>;
    setMetadataUri?(resource: string, uri: Array<string>): Promise<void>;
    model?(name: string): Promise<string>;
    registerModel?(classHash: string): Promise<void>;
    deployContract?(salt: string, classHash: string): Promise<string>;
    upgradeContract?(address: string, classHash: string): Promise<string>;
    uuid?(): Promise<string>;
    entity?(model: string, keys: Array<string>, offset: number, length: number, layout: Array<number>): Promise<Array<bigint>>;
    setEntity?(model: string, keys: Array<string>, offset: number, values: Array<string>, layout: Array<number>): Promise<void>;
    entities?(model: string, index: string | null, values: Array<string>, valuesLength: number, valuesLayout: Array<number>): Promise<Array<Array<bigint>>>;
    entityIds?(model: string): Promise<Array<string>>;
    setExecutor?(contractAddress: string): Promise<void>;
    executor?(): Promise<string>;
    base?(): Promise<string>;
    deleteEntity?(model: string, keys: Array<string>, layout: Array<number>): Promise<void>;
    isOwner?(address: string, resource: string): Promise<boolean>;
    grantOwner?(address: string, resource: string): Promise<void>;
    revokeOwner?(address: string, resource: string): Promise<void>;
    isWriter?(model: string, system: string): Promise<boolean>;
    grantWriter?(model: string, system: string): Promise<void>;
    revokeWriter?(model: string, system: string): Promise<void>;
    worldAge?(): Promise<bigint>;
}

/**
 * Provider class: An abstract base class for all providers.
 * It implements the ICommands interface, ensuring that any class deriving from Provider
 * will have implementations for the entity and entities methods.
 */
declare abstract class Provider implements IWorld {
    private readonly worldAddress;
    /**
     * Constructor: Initializes the Provider with a given world address.
     *
     * @param {string} worldAddress - The address of the world.
     */
    constructor(worldAddress: string);
    /**
     * Abstract method to retrieve a single entity's details.
     * Classes extending Provider should provide a concrete implementation for this method.
     *
     * @param {string} component - The component to query.
     * @param {Query} query - The query details.
     * @param {number} offset - Starting offset.
     * @param {number} length - Length to retrieve.
     * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entity's details.
     */
    abstract entity(model: string, keys: Array<string>, offset: number, length: number, layout: Array<number>): Promise<Array<bigint>>;
    /**
     * Abstract method to retrieve multiple entities' details.
     * Classes extending Provider should provide a concrete implementation for this method.
     *
     * @param {string} component - The component to query.
     * @param {number} length - Number of entities to retrieve.
     * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entities' details.
     */
    abstract entities(model: string, index: string | null, values: Array<string>, valuesLength: number, valuesLayout: Array<number>): Promise<Array<Array<bigint>>>;
    /**
     * Retrieves the stored world address.
     *
     * @returns {string} - The address of the world.
     */
    getWorldAddress(): string;
}

/**
 * DojoProvider: The DojoProvider is an execution provider for dojo worlds. It allows you to easily interact with a dojo world via the Starknet.js library.
 * ```ts
 * import { DojoProvider } from "@dojoengine/core";
 *
 * const provider = new DojoProvider(
 *      manifest
 * );
 *
 * await provider.execute(signer, contract, system, call_data);
 * ```
 */
declare class DojoProvider extends Provider {
    provider: RpcProvider;
    contract: Contract;
    manifest: any;
    /**
     * Constructor: Initializes the DojoProvider with the given world address, manifest and URL.
     *
     * @param {string} world_address - Address of the world.
     * @param {string} [url=LOCAL_KATANA] - RPC URL (defaults to LOCAL_KATANA).
     */
    constructor(manifest?: any, url?: string);
    /**
     * Retrieves a single entity's details.
     *
     * @param {string} model - The component to query.
     * @param {Array<string>} keys - The keys to query.
     * @param {number} [offset=0] - Starting offset (defaults to 0).
     * @param {number} [length=0] - Length to retrieve (defaults to 0).
     * @returns {Promise<Array<bigint>>} - A promise that resolves to an array of bigints representing the entity's details.
     */
    entity(model: string, keys: Array<string>, offset: number | undefined, length: number | undefined, layout: Array<number>): Promise<Array<bigint>>;
    /**
     * Retrieves multiple entities' details.
     *
     * @param {string} model - The component to query.
     * @param {number} index - The index to query.
     * @param {Array<string>} values - The values to query.
     * @param {number} valuesLength - The values length to query.
     * @param {Array<number>} valuesLayout - The values layout to query.
     */
    entities(model: string, index: string, values: Array<string>, valuesLength: number, valuesLayout: Array<number>): Promise<Array<Array<bigint>>>;
    /**
     * Retrieves a models
     *
     * @param {string} name - Name of the model.
     * @returns {Promise<bigint>} - A promise that resolves to a bigint representing the model's details.
     */
    model(name: string): Promise<bigint>;
    /**
     * Executes a function with the given parameters.
     * This function is a wrapper around the Starknet.js Account.execute function, but is more convenient to use.
     *
     * ```ts
     * await provider.execute(signer, contract, system, call_data);
     * ```
     * @param {Account} account - The account to use.
     * @param {string} contract - The contract to execute.
     * @param {string} call - The function to call.
     * @param {num.BigNumberish[]} call_data - The call data for the function.
     * @param {InvocationsDetails | undefined} transactionDetails - The transactionDetails allow to override maxFee & version
     * @returns {Promise<InvokeFunctionResponse>} - A promise that resolves to the response of the function execution.
     */
    execute(account: Account, contract_name: string, call: string, calldata: num.BigNumberish[], transactionDetails?: InvocationsDetails | undefined): Promise<InvokeFunctionResponse>;
    /**
     * Executes a multicall.
     * This function is a wrapper around the Starknet.js Account.execute function, but allows for executing multiple calls at once.
     *
     * ```ts
     * await provider.executeMulti(account, calls);
     * ```
     * @param {Account} account - The account to use.
     * @param {AllowArray<Call>} calls - The calls to execute.
     * @param {InvocationsDetails | undefined} transactionDetails - The transactionDetails allow to override maxFee & version
     * @returns {Promise<InvokeFunctionResponse>} - A promise that resolves to the response of the function execution.
     */
    executeMulti(account: Account, calls: AllowArray<Call>, transactionDetails?: InvocationsDetails | undefined): Promise<InvokeFunctionResponse>;
    /**
     * Retrieves current uuid from the world contract.
     *
     * @returns {Promise<number>} - A promise that resolves to the world uuid
     * @throws {Error} - Throws an error if the call fails.
     *
     * @example
     * const uuid = await provider.uuid();
     * console.log(uuid);
     * // => 6
     *
     */
    uuid(): Promise<number>;
    /**
     * Calls a function with the given parameters.
     *
     * @param {string} contract - The contract to call.
     * @param {string} call - The function to call.
     * @returns {Promise<CallContractResponse>} - A promise that resolves to the response of the function call.
     */
    call(contract_name: string, call: string, calldata?: num.BigNumberish[]): Promise<CallContractResponse>;
}

/**
 * Gets a contract from a manifest by name.
 *
 * @param {any} manifest - The manifest object.
 * @param {string} name - The name of the contract.
 * @returns {any} The contract object.
 *
 */
declare const getContractByName: (manifest: any, name: string) => any;
/**
 * Parses a model name into a class name.
 *
 * @param {any} model - The model object.
 * @returns {string} The class name.
 *
 */
declare const parseModelName: (model: any) => any;

export { DojoProvider, type IWorld, WorldEntryPoints, getContractByName, parseModelName };
